<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Landscape</title>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      background-color: #343351;
    }
  </style>
</head>

<body>

  <canvas id="myCanvas"></canvas>

  <script>
    //create and setup canvas
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    //handle resizing
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); //clears canvas
    ////////////////////////////////

    /* how to draw a line
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    */

    class Mountain {
      constructor(minHeight, peakHeight, color) {
        this.minHeight = minHeight;
        this.peakHeight = peakHeight;
        this.color = color;
        this.points = [];
      }
      updateAndDraw(offsetX = 0) {
        this.points = this.points || [];

        //remove points that are off left screen
        this.points = this.points.filter(p => p[0] >= offsetX - 70 && p[0] <= canvas.width + offsetX + 70);

        //console.log(this.points);

        //if empty, add starting point
        if (this.points.length === 0) {
          this.points.push([offsetX, (this.minHeight + this.peakHeight) / 2]);
        }

        //add new points if needed
        let currentHeight = this.points[this.points.length - 1][1];
        let x = this.points[this.points.length - 1][0];
        while (this.points[this.points.length - 1][0] - offsetX < canvas.width) {
          currentHeight += (Math.random() * 2 - 1.1) * 100;
          x += Math.random() * 50 + 20; // Random width between peaks
          if (currentHeight < this.minHeight) currentHeight = this.minHeight + Math.random() * 20;
          if (currentHeight > this.peakHeight) currentHeight = this.peakHeight - Math.random() * 20;
          this.points.push([x, currentHeight]);
        }

        //draw
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(-300, canvas.height);
        for (let i = 0; i < this.points.length; i++) {
          ctx.lineTo(this.points[i][0] - offsetX, canvas.height - this.points[i][1]);
        }
        ctx.lineTo(canvas.width, canvas.height - currentHeight);
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
      }
    };

    //mountains line
    function drawMountains(minHeight, peakHeight, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      let x = 0;
      let currentHeight = (minHeight + peakHeight) / 2;
      while (x < canvas.width) {
        currentHeight += (Math.random() * 2 - 1.1) * 100;
        if (currentHeight < minHeight) currentHeight = minHeight + Math.random() * 20;
        if (currentHeight > peakHeight) currentHeight = peakHeight - Math.random() * 20;
        ctx.lineTo(x, canvas.height - currentHeight);
        x += Math.random() * 50 + 20; // Random width between peaks
      }
      ctx.lineTo(canvas.width, canvas.height - currentHeight);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      ctx.fill();
    }

    //moon
    function drawMoon() {
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height * 1 / 3, 150, 0, Math.PI * 2); // full circle
      ctx.fillStyle = 'white';
      ctx.shadowBlur = 500;
      ctx.shadowColor = 'white';
      ctx.fill();
    }

    function drawLandscape(skyColor, shadowColor, mountainColor1, mountainColor2, mountainColor3) {
      ctx.save();
      // Draw sky
      ctx.fillStyle = skyColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      //draw moon
      drawMoon();

      ctx.shadowBlur = 500;
      ctx.shadowColor = shadowColor;

      // Draw mountains
      drawMountains(400, 700, mountainColor1); // Distant mountains
      drawMountains(150, 450, mountainColor2); // Closer mountains
      drawMountains(50, 200, mountainColor3); // Closest mountains
      ctx.restore();
    }

    //draw multiple layers of mountains
    //drawLandscape('#343351', 'gray', '#000000', '#1a1a1a', '#333333');
    //drawLandscape('#5c7fa3', '#d1be2b', '#75531e', '#936a2c', '#a97d3c');

    function drawBottomGlow(color) {
      ctx.beginPath();
      ctx.moveTo(0, canvas.height + 10);
      ctx.lineTo(canvas.width, canvas.height + 10);
      ctx.lineWidth = 20;
      ctx.shadowBlur = 100;
      ctx.shadowColor = color;
      ctx.stroke();
    }

    //octos stuff
    let scrollSpeed = 1;
    function updateScrollSpeed(newSpeed) {
      scrollSpeed = newSpeed;
    }
    
    ///////////////

    let offset = 0;
    const mountains = [
      new Mountain(400, 700, '#000000'),
      new Mountain(150, 450, '#111114'),
      new Mountain(50, 200, '#1f1f1f')
    ];

    ///////////////////////////////
    //animation loop
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawMoon();
      offset += scrollSpeed / 2; // Move mountains to the left
      ctx.shadowBlur = 500;
      ctx.shadowColor = 'gray';
      mountains[0].updateAndDraw(offset * 0.5);
      mountains[1].updateAndDraw(offset * 0.8);
      mountains[2].updateAndDraw(offset);
      //mountains.forEach(mtn => mtn.updateAndDraw(offset));

      drawBottomGlow('darkblue');

      requestAnimationFrame(animate);
    }
    animate();

    ////////////////////////////////

  </script>

</body>

</html>