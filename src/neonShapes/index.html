<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ShaderToy Runner - External Shader</title>
<style>
  html,body { margin:0; height:100%; background:black; }
  canvas { width:100%; height:100%; display:block; cursor:default; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2");
if (!gl) { alert("WebGL2 not supported"); }

// -------------------- CONFIG --------------------
// Set your fragment shader file here
const FRAG_SHADER_URL = "patterns.glsl"; ////////////////////////////////////////////////////////////////////////////
// -------------------------------------------------

// Resize handling
function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener("resize", resize);
resize();

// Vertex shader (fullscreen triangle)
const vertSrc = `#version 300 es
void main() {
  vec2 pos = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);
  gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);
}
`;

// -------------------- SHADER LOADER --------------------
async function loadShader(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to load shader: ${url}`);
    return await res.text();
}

function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        throw new Error("Shader compile failed");
    }
    return s;
}

function createProgram(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(p));
        throw new Error("Program link failed");
    }
    return p;
}

// -------------------- MOUSE STATE --------------------
let mouse = {x:0, y:0, down:false, clickX:0, clickY:0};
let lastOffset = {x:0, y:0};

canvas.addEventListener("mousedown", e => {
    mouse.down = true;
    mouse.clickX = e.clientX;
    mouse.clickY = e.clientY;
});

canvas.addEventListener("mouseup", () => {
    mouse.down = false;
    lastOffset.x += mouse.x - mouse.clickX;
    lastOffset.y += mouse.clickY - mouse.y; // invert Y for ShaderToy convention
});

canvas.addEventListener("mousemove", e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});

// -------------------- MAIN --------------------

let program, uTime, uRes, uMouse;
let uBrightness, uComplexity, uColor, uTweak1, uTweak2, uColorScheme;

// Default values for uniforms
let shaderUniforms = {
    // Defaults from octos.json
    brightness: 1.0, // brightness: 1
    complexity: 2, // complexity: 2
    color: [0.3, 0.6, 0.9], // color: #4d99e6
    tweak1: 1.3, // tweak1 (was symmetry)
    tweak2: 0.5, // tweak2 (was angle)
    colorScheme: 0 // colorScheme: "Custom" (index 0)
};

async function initShader() {
    const fragSrc = await loadShader(FRAG_SHADER_URL);
    program = createProgram(
        compile(vertSrc, gl.VERTEX_SHADER),
        compile(fragSrc, gl.FRAGMENT_SHADER)
    );
    gl.useProgram(program);

    // Uniform locations
    uTime = gl.getUniformLocation(program, "iTime");
    uRes = gl.getUniformLocation(program, "iResolution");
    uMouse = gl.getUniformLocation(program, "iMouse");
    uBrightness = gl.getUniformLocation(program, "iBrightness");
    uComplexity = gl.getUniformLocation(program, "iComplexity");
    uColor = gl.getUniformLocation(program, "iColor");
    uTweak1 = gl.getUniformLocation(program, "iVar1");
    uTweak2 = gl.getUniformLocation(program, "iVar2");
    uColorScheme = gl.getUniformLocation(program, "iColorScheme");
}


function render(t) {
    if (!program) return requestAnimationFrame(render);

    gl.uniform1f(uTime, t * 0.001);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    const mouseX = mouse.down ? lastOffset.x + (mouse.x - mouse.clickX) : lastOffset.x;
    const mouseY = mouse.down ? lastOffset.y + (mouse.clickY - mouse.y) : lastOffset.y;

    gl.uniform4f(uMouse,
        mouseX, mouseY,
        mouse.down ? mouse.clickX : 0.0,
        mouse.down ? mouse.clickY : 0.0
    );

    // Pass custom uniforms to shader
    if (uBrightness) gl.uniform1f(uBrightness, shaderUniforms.brightness);
    if (uComplexity) gl.uniform1i(uComplexity, shaderUniforms.complexity);
    if (uColor) gl.uniform3fv(uColor, shaderUniforms.color);
    if (uTweak1) gl.uniform1f(uTweak1, shaderUniforms.tweak1);
    if (uTweak2) gl.uniform1f(uTweak2, shaderUniforms.tweak2);
    if (uColorScheme) gl.uniform1i(uColorScheme, shaderUniforms.colorScheme);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(render);
}


//octos settings
function updateColorScheme(n) {
    if (n === "Custom") n = 0;
    else if (n === "Rainbow") n = 1;
    else n = 0; //default to custom
    shaderUniforms.colorScheme = n;
}
window.updateColorScheme = updateColorScheme;

function updateBrightness(n) {
    shaderUniforms.brightness = n;
}
window.updateBrightness = updateBrightness;

function updateComplexity(n) {
    shaderUniforms.complexity = n;
}
window.updateComplexity = updateComplexity;

function updateTweak1(n) {
    shaderUniforms.tweak1 = n;
}
window.updateTweak1 = updateTweak1;

function updateTweak2(n) {
    shaderUniforms.tweak2 = n;
}
window.updateTweak2 = updateTweak2;
function updateCustomColor(color) {
    //convert color, a hex string, to rgb array
    const r = parseInt(color.slice(1,3), 16) / 255;
    const g = parseInt(color.slice(3,5), 16) / 255;
    const b = parseInt(color.slice(5,7), 16) / 255;
    shaderUniforms.color = [r, g, b];
}
window.updateCustomColor = updateCustomColor;

// Initialize
initShader();
render();
</script>
</body>
</html>
