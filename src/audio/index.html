<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Simple Media Player with FFT.js</title>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #000;
            user-select: none;
        }

        * {
            box-sizing: border-box;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: #000;
        }

        #overlay-container {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            filter: blur(4px);
            transition: opacity 0.5s ease, filter 0.5s ease;
        }

        #overlay-container.active {
            opacity: 1;
            filter: none;
        }

        .overlay {
            position: relative;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            gap: 35px;
            z-index: 1;
            /* min-width: 400px; */
            height: min-content;
            background-color: #222222aa;
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            padding: 35px;
            backdrop-filter: blur(2px);
            height: 220px;
        }

        #thumbnail {
            display: block;
            position: relative;
            float: left;
            width: 150px;
            height: 150px;
            border-radius: 4px;
            border: 1px solid #555;
            opacity: 0.5;
        }

        .info {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .props {
            width: 100%;
        }

        .props * {
            margin: 0;
            width: max-content;
            max-width: 175px;
        }

        #title {
            font-size: 16pt;
            margin-bottom: 5px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #artist {
            font-size: 12pt;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .controls {
            display: flex;
            width: 175px;
            height: max-content;
            flex-direction: column;
            align-items: center;
        }

        .playback {
            width: 100%;
            max-width: 175px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
            font-size: 16pt;
            color: #444;
        }

        #timeline {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #444;
            border-color: transparent;
            border-radius: 5px;
            outline: none;
        }

        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #aaa;
            border-radius: 50%;
            cursor: pointer;
        }

        #thumbnail[alt]:after {
            content: "\ee04";
            font-family: 'remixicon' !important;
            display: block;
            font-size: 64pt;
            position: absolute;
            color: #fff;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            font-weight: 300;
            text-align: center;
            line-height: 150px;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="overlay-container">
        <div class="overlay">
            <img id="thumbnail" src="" alt="" draggable="false" />
            <div class="info">
                <div class="props">
                    <h2 id="title">Title</h2>
                    <p id="artist">Artist</p>
                </div>
                <div class="controls">
                    <input id="timeline" type="range" min="0" max="100" value="0" step="1" />
                    <div class="playback">
                        <i class="ri-skip-back-fill" id="skipBack"></i>
                        <i class="ri-play-large-fill" id="playPause"></i>
                        <i class="ri-skip-forward-fill" id="skipForward"></i>
                    </div>
                </div>
            </div>
            <!-- <div class=""></div> -->
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/octos@0.1.2/octos.min.js"></script>
    <script type="module">
        import FFT from 'https://cdn.skypack.dev/fft.js';

        // media controls
        const mediaController = new octos.MediaController();
        const playPause = document.getElementById('playPause');
        const skipForward = document.getElementById('skipForward');
        const skipBack = document.getElementById('skipBack');
        const timeline = document.getElementById('timeline');
        const overlayContainer = document.getElementById('overlay-container');
        let active = false;

        function updateMediaProps(props) {
            if (props.title) {
                document.getElementById('title').innerText = props.title;
                document.getElementById('artist').innerText = props.artist;
            }
        }

        function updatePlaybackInfo(playbackInfo) {
            console.log(playbackInfo.playbackStatus)
            if (playbackInfo.playbackStatus == 'Playing' || playbackInfo.playbackStatus == 'Paused') {
                overlayContainer.classList.add('active')
                updatePlayPause(playbackInfo.playbackStatus);
                active = true;
            }
            else {
                overlayContainer.classList.remove('active')
                setTimeout(() => {
                    active = false
                    drawRadialPattern()
                }, 500);
            }
        }

        function updateThumbnail(src) {
            if (active)
                document.getElementById('thumbnail').src = src || "";
        }

        function updateTimeline(props) {
            timeline.setAttribute('max', props.maxSeekTime);
            timeline.setAttribute('min', props.minSeekTime);
            timeline.value = props.position;
        }

        mediaController.on('playbackChange', playbackInfo => {
            updatePlaybackInfo(playbackInfo);
        });

        mediaController.on('mediaChange', mediaProps => {
            updateMediaProps(mediaProps);
            mediaController.requestThumbnail().then(updateThumbnail);
        });

        mediaController.on('timelineChange', timeProps => {
            updateTimeline(timeProps);
        });

        playPause.onclick = () => {
            mediaController.togglePlayPause();
            mediaController.requestTimelineProperties().then(updateTimeline);
        };
        skipForward.onclick = () => {
            mediaController.skipNext();
            mediaController.requestTimelineProperties().then(updateTimeline);
        };
        skipBack.onclick = () => {
            mediaController.skipPrevious();
            mediaController.requestTimelineProperties().then(updateTimeline);
        };
        timeline.onchange = () => {
            mediaController.setSeekPosition(parseInt(timeline.value))
        }

        function updatePlayPause(status) {
            playPause.className = status == 'Playing' ? 'ri-pause-large-fill' : 'ri-play-large-fill';
        }

        document.addEventListener('DOMContentLoaded', () => {
            drawRadialPattern()
            mediaController.requestMediaProperties().then(updateMediaProps);
            mediaController.requestThumbnail().then(updateThumbnail);
            mediaController.requestPlaybackInfo().then(updatePlaybackInfo);
            mediaController.requestTimelineProperties().then(updateTimeline);
        });

        // visualization
        const fftSize = 1024;
        const fft = new FFT(fftSize);
        const input = new Array(fftSize).fill(0);
        const output = fft.createComplexArray();

        const displayBars = 128;

        let smoothedMagnitudes = new Array(displayBars).fill(0);

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const SMOOTHING_FACTOR = 0.8;

        function getLogFrequencyBins(linearMags, sampleRate = 44100) {
            const nyquist = sampleRate / 2;
            const logBins = new Array(displayBars).fill(0);
            const logMinFreq = Math.log10(100);
            const logMaxFreq = Math.log10(nyquist);
            const binCount = linearMags.length;
            for (let i = 0; i < displayBars; i++) {
                const freqStart = Math.pow(10, logMinFreq + (i / displayBars) * (logMaxFreq - logMinFreq));
                const freqEnd = Math.pow(10, logMinFreq + ((i + 1) / displayBars) * (logMaxFreq - logMinFreq));
                const startBin = Math.floor(freqStart / nyquist * binCount);
                const endBin = Math.min(binCount - 1, Math.ceil(freqEnd / nyquist * binCount));

                let sum = 0;
                let count = 0;
                for (let bin = startBin; bin <= endBin; bin++) {
                    sum += linearMags[bin];
                    count++;
                }
                logBins[i] = count > 0 ? sum / count : 0;
            }
            return logBins;
        }

        function handleAudioStream(audioStream) {
            if (!active)
                return;
            const samples = audioStream.samples;
            const channels = audioStream.channels;
            const mono = [];
            for (let i = 0; i < samples.length; i += channels) {
                let sum = 0;
                for (let c = 0; c < channels; c++) {
                    sum += samples[i + c];
                }
                mono.push(sum / channels);
            }
            const mean = mono.reduce((acc, val) => acc + val, 0) / mono.length;
            for (let i = 0; i < fftSize; i++) {
                input[i] = (mono[i] !== undefined ? mono[i] : 0) - mean;
            }
            fft.realTransform(output, input);
            fft.completeSpectrum(output);
            const linearMagnitudes = new Array(fftSize / 2);
            for (let i = 0; i < fftSize / 2; i++) {
                const re = output[2 * i];
                const im = output[2 * i + 1];
                linearMagnitudes[i] = Math.sqrt(re * re + im * im);
            }
            const logMagnitudes = getLogFrequencyBins(linearMagnitudes);
            for (let i = 0; i < displayBars; i++) {
                smoothedMagnitudes[i] = SMOOTHING_FACTOR * smoothedMagnitudes[i] + (1 - SMOOTHING_FACTOR) * logMagnitudes[i];
            }
            // const edgeSmoothFactor = 1;
            // const first = smoothedMagnitudes[0];
            // const last = smoothedMagnitudes[displayBars - 1];
            // smoothedMagnitudes[0] = edgeSmoothFactor * last + (1 - edgeSmoothFactor) * first;
            // smoothedMagnitudes[displayBars - 1] = edgeSmoothFactor * first + (1 - edgeSmoothFactor) * last;
            smoothedMagnitudes[displayBars - 1] = smoothedMagnitudes[displayBars - 2]
            requestAnimationFrame(draw);
        }

        function drawRadialPattern() {
            if (active)
                return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const drawWave = (baseRadius = 30, amplitude = 30, waveCount = 6, rot = 0) => {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const points = 100;
                ctx.beginPath();
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * 2 * Math.PI;
                    const rotatedAngle = angle + rot; // add rotation here
                    const radius = baseRadius + amplitude * Math.sin(waveCount * angle);
                    const x = centerX + radius * Math.cos(rotatedAngle);
                    const y = centerY + radius * Math.sin(rotatedAngle);

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            const pulse = (x) => Math.cos(performance.now() / 2000 + x);
            const rotate = performance.now() / 8000
            ctx.strokeStyle = 'blue'
            ctx.fillStyle = 'rgba(0, 0, 255, 0.2)';
            drawWave(250 + 10 * pulse(0), 20 + 5 * pulse(0), 12, -rotate / 3);

            ctx.strokeStyle = 'red'
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            drawWave(175 + 10 * pulse(Math.PI / 2), 10 + 5 * pulse(0), 10, rotate / 2);

            ctx.strokeStyle = 'green'
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            drawWave(100 + 10 * pulse(Math.PI), 10, 6, -rotate);

            setTimeout(() => requestAnimationFrame(drawRadialPattern), 60);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / displayBars;
            const maxHeight = canvas.height;

            const gradient = ctx.createLinearGradient(0, 0, 0, maxHeight);
            gradient.addColorStop(0, '#00ff00');
            gradient.addColorStop(1, '#003300');
            ctx.fillStyle = gradient;

            // const drawSpectrum = (mult) => {
            //     ctx.beginPath()
            //     for (let i = 0; i < displayBars; i++) {
            //         let mag = smoothedMagnitudes[i];
            //         let db = 20 * Math.log10(mag);
            //         if (!isFinite(db)) db = -100;
            //         const barHeight = db * mult
            //         const x = i * barWidth;
            //         const y = maxHeight - barHeight;
            //         if (i == 0)
            //             ctx.moveTo(x, y)
            //         else
            //             ctx.lineTo(x, y)
            //         if (i == displayBars - 1) {
            //             ctx.lineTo(x + i * barWidth, y)
            //         }
            //     }
            //     ctx.lineTo(canvas.width, canvas.height);
            //     ctx.lineTo(0, canvas.height)
            //     ctx.closePath();
            //     ctx.fill();
            //     ctx.stroke();
            // }

            const drawSpectrum = (mult) => {
                ctx.beginPath();

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const baseRadius = 50;
                const angleStep = (2 * Math.PI) / displayBars;

                for (let i = 0; i < displayBars; i++) {
                    let mag = smoothedMagnitudes[i];
                    let db = 20 * Math.log10(mag);
                    if (!isFinite(db)) db = -100;

                    const reduction = 1 - (1 - i / displayBars) * 0.4;
                    let radius = (baseRadius + db * mult) * reduction;
                    radius = radius > 0 ? radius : 0
                    const angle = i * angleStep + performance.now() / 8000;

                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            };

            ctx.strokeStyle = 'blue'
            ctx.fillStyle = 'rgba(0, 0, 255, 0.2)';
            drawSpectrum(20);

            ctx.strokeStyle = 'red'
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
            drawSpectrum(15);

            ctx.strokeStyle = 'green'
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            drawSpectrum(10);
        }

        mediaController.on('audioStream', handleAudioStream);
    </script>
</body>

</html>