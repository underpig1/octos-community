<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - materials - car</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #bbbbbb;
            background: #333333;
            overflow: hidden;
            user-select: none;
            width: 100%;
            height: 100%;
        }

        .colorPicker {
            display: inline-block;
            margin: 0 10px
        }

        #info {
            position: absolute;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="https://cdn.jsdelivr.net/npm/octos@0.1.2/octos.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { RGBELoader  } from 'three/addons/loaders/RGBELoader.js';
        let HDRLoader = RGBELoader;

        let userOptions = new octos.UserOptions();

        let camera, scene, renderer;

        let grid;
        let controls;

        const wheels = [];

        function init() {
            const container = document.getElementById('container');

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.85;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(4.25, 1.4, - 4.5);

            controls = new OrbitControls(camera, container);
            controls.maxDistance = 9;
            controls.maxPolarAngle = THREE.MathUtils.degToRad(90);
            controls.target.set(0, 0.5, 0);
            controls.update();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            const hdrLoader = new HDRLoader();
            hdrLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/equirectangular/venice_sunset_1k.hdr', function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            });

            scene.fog = new THREE.Fog(0x333333, 10, 15);

            grid = new THREE.GridHelper(20, 40, 0xffffff, 0xffffff);
            grid.material.opacity = 0.2;
            grid.material.depthWrite = false;
            grid.material.transparent = true;
            scene.add(grid);

            // materials
            const bodyMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
            });
            const detailsMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff, metalness: 1.0, roughness: 0.5
            });
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
            });

            function handleOptions({id, value}) {
                if (id == 'body-color') {
                    bodyMaterial.color.set(value);
                }
                else if (id == 'details-color') {
                    detailsMaterial.color.set(value);
                }
                else if (id == 'glass-color') {
                    glassMaterial.color.set(value);
                }
            }

            userOptions.on('change', handleOptions);
            userOptions.on('load', handleOptions);

            // Car
            const shadow = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/ferrari_ao.png');
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);
            loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/models/gltf/ferrari.glb', function (gltf) {
                const carModel = gltf.scene.children[0];
                carModel.getObjectByName('body').material = bodyMaterial;
                carModel.getObjectByName('rim_fl').material = detailsMaterial;
                carModel.getObjectByName('rim_fr').material = detailsMaterial;
                carModel.getObjectByName('rim_rr').material = detailsMaterial;
                carModel.getObjectByName('rim_rl').material = detailsMaterial;
                carModel.getObjectByName('trim').material = detailsMaterial;
                carModel.getObjectByName('glass').material = glassMaterial;
                wheels.push(
                    carModel.getObjectByName('wheel_fl'),
                    carModel.getObjectByName('wheel_fr'),
                    carModel.getObjectByName('wheel_rl'),
                    carModel.getObjectByName('wheel_rr')
                );
                // shadow
                const mesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.655 * 4, 1.3 * 4),
                    new THREE.MeshBasicMaterial({
                        map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true, premultipliedAlpha: true
                    })
                );
                mesh.rotation.x = - Math.PI / 2;
                mesh.renderOrder = 2;
                carModel.add(mesh);
                scene.add(carModel);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            controls.update();
            // const time = - performance.now() / 1000;
            // for (let i = 0; i < wheels.length; i++) {
            //     wheels[i].rotation.x = time * Math.PI * 2;
            // }
            // grid.position.z = - (time) % 1;
            renderer.render(scene, camera);
        }

        init();

    </script>

</body>

</html>