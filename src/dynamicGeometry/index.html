<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ShaderToy Runner - External Shader</title>
<style>
  html,body { margin:0; height:100%; background:black; }
  canvas { width:100%; height:100%; display:block; cursor:default; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2");
if (!gl) { alert("WebGL2 not supported"); }

// -------------------- CONFIG --------------------
// Set your fragment shader file here
let FRAG_SHADER_URL = "cheeseSticks.glsl"; ////////////////////////////////////////////////////////////////////////////
// -------------------------------------------------

// Resize handling
function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener("resize", resize);
resize();

// Vertex shader (fullscreen triangle)
const vertSrc = `#version 300 es
void main() {
  vec2 pos = vec2((gl_VertexID << 1) & 2, gl_VertexID & 2);
  gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);
}
`;

// -------------------- SHADER LOADER --------------------
async function loadShader(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to load shader: ${url}`);
    return await res.text();
}

function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        throw new Error("Shader compile failed");
    }
    return s;
}

function createProgram(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(p));
        throw new Error("Program link failed");
    }
    return p;
}

// -------------------- MOUSE STATE --------------------
let mouse = {x:0, y:0, down:false, clickX:0, clickY:0};
let lastOffset = {x:0, y:0};

canvas.addEventListener("mousedown", e => {
    mouse.down = true;
    mouse.clickX = e.clientX;
    mouse.clickY = e.clientY;
});

canvas.addEventListener("mouseup", () => {
    mouse.down = false;
    lastOffset.x += mouse.x - mouse.clickX;
    lastOffset.y += mouse.clickY - mouse.y; // invert Y for ShaderToy convention
});

canvas.addEventListener("mousemove", e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});

// -------------------- MAIN --------------------

let program, uTime, uRes, uMouse;
let uColorScheme, uColor1, uColor2, uSpeed;

// Default values for uniforms
let shaderUniforms = {
    // Defaults from octos.json
    //color1: [0.3, 0.6, 0.9], // color1: #4d99e6
    color1: [0.1, 0.1, 0.1], // color1: #1a1a1a
    color2: [0.47, 0.3, 0.9], // color: #784de6
    speed: 1.0, // speed: 1.0
    colorScheme: 0 // colorScheme: "Default" (index 0)
};

async function initShader() {
    const fragSrc = await loadShader(FRAG_SHADER_URL);
    program = createProgram(
        compile(vertSrc, gl.VERTEX_SHADER),
        compile(fragSrc, gl.FRAGMENT_SHADER)
    );
    gl.useProgram(program);

    // Uniform locations
    uTime = gl.getUniformLocation(program, "iTime");
    uRes = gl.getUniformLocation(program, "iResolution");
    uMouse = gl.getUniformLocation(program, "iMouse");
    uColor1 = gl.getUniformLocation(program, "iColor1");
    uColor2 = gl.getUniformLocation(program, "iColor2");
    uSpeed = gl.getUniformLocation(program, "iSpeed");
    uColorScheme = gl.getUniformLocation(program, "iColorScheme");
}


function render(t) {
    if (!program) return requestAnimationFrame(render);

    gl.uniform1f(uTime, t * 0.001);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    const mouseX = mouse.down ? lastOffset.x + (mouse.x - mouse.clickX) : lastOffset.x;
    const mouseY = mouse.down ? lastOffset.y + (mouse.clickY - mouse.y) : lastOffset.y;

    gl.uniform4f(uMouse,
        mouseX, mouseY,
        mouse.down ? mouse.clickX : 0.0,
        mouse.down ? mouse.clickY : 0.0
    );

    // Pass custom uniforms to shader
    if (uColor1) gl.uniform3fv(uColor1, shaderUniforms.color1);
    if (uColor2) gl.uniform3fv(uColor2, shaderUniforms.color2);
    if (uSpeed) gl.uniform1f(uSpeed, shaderUniforms.speed);
    if (uColorScheme) gl.uniform1i(uColorScheme, shaderUniforms.colorScheme);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(render);
}


//octos settings
function updateColorScheme(n) {
    if (n === "Default") n = 0;
    else if (n === "Custom") n = 1;
    else n = 0; //default to Default
    shaderUniforms.colorScheme = n;
}
window.updateColorScheme = updateColorScheme;

async function updateScene(n) {
    if (n === "Spiral") FRAG_SHADER_URL = "cheeseSticks.glsl";
    else if (n === "Worms") FRAG_SHADER_URL = "spiral.glsl";
    else if (n === "Factory") FRAG_SHADER_URL = "factory.glsl";
    else FRAG_SHADER_URL = "cheeseSticks.glsl"; //default to Cheese Sticks
    await initShader(); // Recompile and re-link the shader
}
window.updateScene = updateScene;

function updateSpeed(n) {
    shaderUniforms.speed = n;
}
window.updateSpeed = updateSpeed;

function updateCustomColor1(color) {
    //convert color, a hex string, to rgb array
    const r = parseInt(color.slice(1,3), 16) / 255;
    const g = parseInt(color.slice(3,5), 16) / 255;
    const b = parseInt(color.slice(5,7), 16) / 255;
    shaderUniforms.color1 = [r, g, b];
}
window.updateCustomColor1 = updateCustomColor1;

function updateCustomColor2(color) {
    //convert color, a hex string, to rgb array
    const r = parseInt(color.slice(1,3), 16) / 255;
    const g = parseInt(color.slice(3,5), 16) / 255;
    const b = parseInt(color.slice(5,7), 16) / 255;
    shaderUniforms.color2 = [r, g, b];
}
window.updateCustomColor2 = updateCustomColor2;

// Initialize
initShader();
render();
</script>
</body>
</html>
