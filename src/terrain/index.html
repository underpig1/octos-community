<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pixel Terrain with Houses</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            height: 100vh;
            width: 100vw
        }

        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
            width: 100vw;
            height: 100vh;
            background: #222;
        }
    </style>
</head>

<body>
    <canvas id="screen"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/octos@latest/octos.min.js"></script>
    <script type="module">
        import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.3/dist/esm/simplex-noise.js';
        const noise2D = createNoise2D();

        const canvas = document.getElementById('screen'), ctx = canvas.getContext('2d');
        const pixelSize = 6;
        let cols, rows;

        function resize() {
            cols = Math.floor(window.innerWidth / pixelSize);
            rows = Math.floor(window.innerHeight / pixelSize);
            canvas.width = cols;
            canvas.height = (rows - 1);
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
        resize();
        window.addEventListener('resize', resize);

        function lerpColor(a, b, t) {
            let ah = parseInt(a.slice(1), 16), bh = parseInt(b.slice(1), 16),
                ar = (ah >> 16) & 255, ag = (ah >> 8) & 255, ab = ah & 255,
                br = (bh >> 16) & 255, bg = (bh >> 8) & 255, bb = bh & 255,
                rr = Math.round(ar + t * (br - ar)), rg = Math.round(ag + t * (bg - ag)), rb = Math.round(ab + t * (bb - ab));
            return "#" + ((1 << 24) + (rr << 16) + (rg << 8) + rb).toString(16).slice(1);
        }

        function jitterColor(hex, x, y) {
            const chars = hex.slice(1).split('');
            return '#' + chars.map((ch, i) => {
                let val = parseInt(ch, 16), n = noise2D((x + i) * 0.3, (y + i) * 0.3) * 0.2,
                    delta = n > 0.33 ? 1 : n < -0.33 ? -1 : 0,
                    newVal = Math.min(15, Math.max(0, val + delta));
                return newVal.toString(16);
            }).join('');
        }

        function getHeight(x, y) {
            const baseScale = 0.02;
            let height = 0, amplitude = 4, freq = 1, maxA = 0;
            for (let i = 0; i < 6; i++) {
                height += noise2D(x * baseScale * freq, y * baseScale * freq) * amplitude;
                maxA += amplitude; amplitude *= 0.7; freq *= 2;
            }
            height /= maxA;
            const continent = noise2D(x * baseScale * 0.1, y * baseScale * 0.1) * 0.75;
            height = height * 0.6 + continent * 0.4;
            return Math.pow(height * 0.5 + 0.5, 2.5) * 4 - 1.0;
        }

        function getColor(h, x, y) {
            const n = (h + 1) / 2;
            let color;
            if (n < 0.4) {
                let t = Math.min(1, Math.max(0, n / 0.4 + noise2D(x * 0.1, y * 0.1) * 0.05));
                color = t < 0.33 ? lerpColor('#003b5c', '#005f7a', t / 0.33) : (t < 0.66 ? lerpColor('#005f7a', '#0099cc', (t - 0.33) / 0.33) : lerpColor('#0099cc', '#3399ff', (t - 0.66) / 0.34));
            } else if (n < 0.5) color = lerpColor('#3399ff', '#ffddaa', (n - 0.4) / 0.1);
            else if (n < 0.6) {
                const t = (n - 0.5) / 0.1;
                color = t < 0.3 ? lerpColor('#ffddaa', '#6b8e23', t / 0.3) : '#6b8e23';
            } else if (n < 0.7) color = lerpColor('#6b8e23', '#228B22', (n - 0.6) / 0.1);
            else if (n < 0.8) color = lerpColor('#228B22', '#556b2f', (n - 0.7) / 0.1);
            else if (n < 0.87) {
                const t = (n - 0.8) / 0.07;
                color = t < 0.4 ? lerpColor('#556b2f', '#a0a0a0', t / 0.4) : '#a0a0a0';
            } else if (n < 0.95) color = lerpColor('#a0a0a0', '#c0c0c0', (n - 0.87) / 0.08);
            else color = lerpColor('#c0c0c0', '#ffffff', Math.min((n - 0.95) / 0.05, 1));
            return jitterColor(color, x, y);
        }

        document.onclick = (e) => {
            draw();
        }

        let scrollY = 0;
        const rowCache = new Map()

        function computeRow(y) {
            const row = new Array(cols);
            for (let x = 0; x < cols; x++) {
                const h = getHeight(x, y);
                row[x] = { h, color: getColor(h, x, y) };
            }
            return row;
        }

        // -- THROTTLED DRAW SCHEDULER --
        let drawScheduled = false;
        function scheduleDraw() {
            if (!drawScheduled) {
                drawScheduled = true;
                requestAnimationFrame(() => {
                    draw();
                    drawScheduled = false;
                });
            }
        }

        let isMouseDown = false;

        canvas.addEventListener('mousedown', e => {
            isMouseDown = true;
            applyHeightIncrease(e);
        });

        canvas.addEventListener('mouseup', e => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', e => {
            isMouseDown = false;
        });

        canvas.addEventListener('mousemove', e => {
            if (!isMouseDown) return;
            applyHeightIncrease(e);
        });

        function applyHeightIncrease(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = Math.floor((e.clientX - rect.left) / pixelSize);
            const my = Math.floor((e.clientY - rect.top) / pixelSize);
            const worldY = Math.floor(scrollY) + my;

            const radius = 15;

            for (let dy = -radius; dy <= radius; dy++) {
                const y = worldY + dy;
                const row = rowCache.get(y);
                if (!row) continue;

                for (let dx = -radius; dx <= radius; dx++) {
                    const x = mx + dx;
                    if (x < 0 || x >= cols) continue;

                    if (dx * dx + dy * dy <= radius * radius) {
                        if (row[x]) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const falloff = 1 - dist / radius;
                            row[x].h += 0.1 * falloff;
                            row[x].color = getColor(row[x].h, x, y);
                        }
                    }
                }
            }
            scheduleDraw(); // THROTTLED DRAW
        }

        function draw() {
            ctx.clearRect(0, 0, cols, rows);
            const keep = new Set();
            for (let y = 0; y < rows; y++) {
                const worldY = Math.floor(scrollY) + y;
                keep.add(worldY);
                if (!rowCache.has(worldY)) rowCache.set(worldY, computeRow(worldY));
                const row = rowCache.get(worldY);
                for (let x = 0; x < cols; x++) {
                    ctx.fillStyle = row[x].color;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            for (const key of rowCache.keys()) {
                if (!keep.has(key)) rowCache.delete(key);
            }
        }

        const userOptions = new octos.UserOptions();

        const handleOptions = ({ id, value }) => {
            if (id == 'speed') {
                if (value) {
                    if (parseInt(value) == 0) interval = Infinity
                    else if (parseInt(value) == 5) interval = 100
                    else
                        interval = 1000 - parseInt(value)*2 * 100
                }
            }
        };

        userOptions.on('change', handleOptions)
        userOptions.on('load', handleOptions)

        let scrollSpeed = 1;
        let lastTime = 0, interval = 500;

        function animate(time = 0) {
            if (!isMouseDown) {
                if (time - lastTime > interval) {
                    scrollY += scrollSpeed;
                    draw();
                    lastTime = time;
                }
            }
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>

</html>