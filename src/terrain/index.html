<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #111;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        (() => {
            let SCALE = 4;

            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl2');
            if (!gl) return alert('WebGL2 required');

            let W = canvas.width = innerWidth;
            let H = canvas.height = innerHeight;
            let chunkW = Math.floor(W / SCALE);
            let chunkH = Math.floor(H / SCALE);
            let aspect = W / H;

            const ext = gl.getExtension('EXT_color_buffer_float');
            if (!ext) alert('Floating-point render targets not supported!');

            function compile(src, type) {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
                return s;
            }
            function createProgram(vs, fs) {
                const p = gl.createProgram();
                gl.attachShader(p, compile(vs, gl.VERTEX_SHADER));
                gl.attachShader(p, compile(fs, gl.FRAGMENT_SHADER));
                gl.linkProgram(p);
                if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
                return p;
            }

            const quadVerts = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
            const quadVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
            gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
            function setupAttribs(prog) {
                const aPos = gl.getAttribLocation(prog, 'aPos');
                gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
                gl.enableVertexAttribArray(aPos);
                gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
            }

            const VS = `#version 300 es
    in vec2 aPos;
    out vec2 vUV;
    void main(){ vUV = aPos*0.5 + 0.5; gl_Position=vec4(aPos,0,1); }
    `;

            const DOT_BRUSH_FS = `#version 300 es
    precision highp float;
    out vec4 outColor;
    uniform vec2 uDotPos;
    uniform float uRadius;
    uniform float uAmount;
    uniform float uAspect;
    in vec2 vUV;
    void main(){
        vec2 diff = vec2((vUV.x-uDotPos.x)*uAspect, vUV.y-uDotPos.y);
        float d = length(diff);
        if(d<uRadius){
            float factor = 1.0-(d/uRadius)*(d/uRadius);
            outColor=vec4(uAmount*factor,0.,0.,1.);
        } else discard;
    }`;
            const dotBrushProg = createProgram(VS, DOT_BRUSH_FS);
            const locDot = {
                uDotPos: gl.getUniformLocation(dotBrushProg, 'uDotPos'),
                uRadius: gl.getUniformLocation(dotBrushProg, 'uRadius'),
                uAmount: gl.getUniformLocation(dotBrushProg, 'uAmount'),
                uAspect: gl.getUniformLocation(dotBrushProg, 'uAspect')
            };

            const TERRAIN_FS = `#version 300 es
    precision highp float;
    in vec2 vUV;
    out vec4 outColor;
    uniform sampler2D uChunk0;
    uniform sampler2D uChunk1;
    uniform float uCameraTop;
    uniform float uChunk0Base;
    uniform float uChunkSize;
    uniform vec2 uResolution;
uniform vec3 uPalette[11];

    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
    //float noise(vec2 p){ vec2 i=floor(p),f=fract(p); float a=hash(i),b=hash(i+vec2(1.,0.)),c=hash(i+vec2(0.,1.)),d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }

    // 2D Simplex noise from Ian McEwan (Ashima Arts)
vec3 mod289(vec3 x){return x - floor(x* (1.0/289.0))*289.0;}
vec2 mod289(vec2 x){return x - floor(x* (1.0/289.0))*289.0;}
vec3 permute(vec3 x){return mod289(((x*34.0)+1.0)*x);}
float noise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  vec2 i = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289(i);
  vec3 p = permute( permute(i.y + vec3(0.0, i1.y, 1.0))
      + i.x + vec3(0.0, i1.x, 1.0) );
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x = a0.x * x0.x + h.x * x0.y;
  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return 130.0 * dot(m, g);
}


    float getHeight(vec2 p) {
    // Base noise scale and parameters
    float baseScale = 0.01;
    float height = 0.0;
    float amplitude = 4.0; 
    float freq = 1.0;
    float maxA = 0.0;

    // Accumulate noise at multiple octaves
    for (int i = 0; i < 6; i++) {
        height += noise(p * baseScale * freq) * amplitude;
        maxA += amplitude;
        amplitude *= 0.7;
        freq *= 2.0;
    }
    height /= maxA;

    // Add continent-like features
    float continent = noise(p * baseScale * 0.1) * 0.75;
    height = height * 0.6 + continent * 0.4;

    // Apply a power function for more dramatic elevation changes
    return pow(height * 0.5 + 0.5, 2.5) * 4.0 - 1.0;
}


    vec3 lerpColor(vec3 a, vec3 b, float t){ return a + (b-a)*t; }
    float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
    vec3 jitterColor(vec3 color, vec2 worldXY){
        float rShift=(rand(worldXY*0.3)-0.5)*0.05;
        float gShift=(rand(worldXY*0.7)-0.5)*0.05;
        float bShift=(rand(worldXY*1.3)-0.5)*0.05;
        return clamp(color+vec3(rShift,gShift,bShift),0.0,1.0);
    }

    vec3 getColor(float h, vec2 p){
    float n=(h+1.0)/2.0; vec3 color;
    if(n<0.4){ float t=clamp(n/0.4 + noise(p*0.1)*0.05,0.0,1.0);
        if(t<0.33) color=lerpColor(uPalette[0],uPalette[1],t/0.33);
        else if(t<0.66) color=lerpColor(uPalette[1],uPalette[2],(t-0.33)/0.33);
        else color=lerpColor(uPalette[2],uPalette[3],(t-0.66)/0.34);
    } else if(n<0.5) color=lerpColor(uPalette[3],uPalette[4],(n-0.4)/0.1);
    else if(n<0.6){ float t=(n-0.5)/0.1; if(t<0.3) color=lerpColor(uPalette[4],uPalette[5],t/0.3); else color=uPalette[5]; }
    else if(n<0.7) color=lerpColor(uPalette[5],uPalette[6],(n-0.6)/0.1);
    else if(n<0.8) color=lerpColor(uPalette[6],uPalette[7],(n-0.7)/0.1);
    else if(n<0.87){ float t=(n-0.8)/0.07; if(t<0.4) color=lerpColor(uPalette[7],uPalette[8],t/0.4); else color=uPalette[8];}
    else if(n<0.95) color=lerpColor(uPalette[8],uPalette[9],(n-0.87)/0.08);
    else color=lerpColor(uPalette[9],uPalette[10],clamp((n-0.95)/0.05,0.0,1.0));
    return color;
}


    void main(){
        float aspect = uResolution.x/uResolution.y;
        vec2 texelUV = floor(vUV * uResolution) / uResolution;
vec2 worldPos = vec2(vUV.x * aspect * uResolution.y, uCameraTop + vUV.y * uResolution.y);
vec2 pixelated = floor(worldPos) + 0.5; // snap to nearest integer world position
vec2 worldXY = pixelated;


        float sampleDelta=0.0;
        if(worldXY.y>=uChunk0Base && worldXY.y<uChunk0Base+uChunkSize){
            float ly=(worldXY.y-uChunk0Base)/uChunkSize; ly=clamp(ly,0.0,1.0);
            sampleDelta=texture(uChunk0,vec2(vUV.x,ly)).r;
        } else {
            float chunk1Base=uChunk0Base+uChunkSize;
            float ly=(worldXY.y-chunk1Base)/uChunkSize; ly=clamp(ly,0.0,1.0);
            sampleDelta=texture(uChunk1,vec2(vUV.x,ly)).r;
        }
        float h=getHeight(worldXY)+sampleDelta;
        vec3 col=getColor(h,worldXY);
        col=jitterColor(col,worldXY);
        outColor=vec4(col,1.0);
    }`;
            const terrainProg = createProgram(VS, TERRAIN_FS);

            // --- Chunks ---
            function createChunk() {
                const tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA32F,
                    chunkW,
                    chunkH,
                    0,
                    gl.RGBA,
                    gl.FLOAT,
                    null
                );
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) console.error("Chunk framebuffer incomplete!");
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                return { tex, fbo, base: 0 };
            }

            let chunk0 = createChunk(), chunk1 = createChunk();
            chunk0.base = 0; chunk1.base = chunkH;

            const locTerrain = {
                uChunk0: gl.getUniformLocation(terrainProg, 'uChunk0'),
                uChunk1: gl.getUniformLocation(terrainProg, 'uChunk1'),
                uCameraTop: gl.getUniformLocation(terrainProg, 'uCameraTop'),
                uChunk0Base: gl.getUniformLocation(terrainProg, 'uChunk0Base'),
                uChunkSize: gl.getUniformLocation(terrainProg, 'uChunkSize'),
                uResolution: gl.getUniformLocation(terrainProg, 'uResolution'),
                uPalette: gl.getUniformLocation(terrainProg, 'uPalette')
            };

            const mouse = { x: 0, y: 0, down: false };
            canvas.addEventListener('mousemove', e => { const r = canvas.getBoundingClientRect(); mouse.x = (e.clientX - r.left) / W; mouse.y = (e.clientY - r.top) / H; });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            window.addEventListener('mouseup', () => mouse.down = false);

            function drawDotContinuous(xNorm, yNorm) {
                const dotRadius = 0.05, heightIncrement = 0.03;
                [chunk0, chunk1].forEach(chunk => {
                    const yInChunk = (1 - yNorm) * chunkH - (chunk.base - cameraTop);
                    const yChunkNorm = yInChunk / chunkH;
                    if (yChunkNorm + dotRadius >= 0 && yChunkNorm - dotRadius <= 1) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, chunk.fbo);
                        gl.viewport(0, 0, chunkW, chunkH);
                        gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE);
                        gl.useProgram(dotBrushProg); setupAttribs(dotBrushProg);
                        gl.uniform2f(locDot.uDotPos, xNorm, yChunkNorm);
                        gl.uniform1f(locDot.uRadius, dotRadius);
                        gl.uniform1f(locDot.uAmount, heightIncrement);
                        gl.uniform1f(locDot.uAspect, aspect);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        gl.disable(gl.BLEND); gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    }
                });
            }

            canvas.addEventListener('mousedown', () => drawDotContinuous(mouse.x, mouse.y));
            canvas.addEventListener('mousemove', () => { if (mouse.down) drawDotContinuous(mouse.x, mouse.y); });

            let cameraTop = 0, scrollSpeed = 0.05;

            function frame() {
                cameraTop += scrollSpeed;
                if (cameraTop >= chunk1.base) {
                    [chunk0, chunk1] = [chunk1, chunk0];
                    chunk1.base = chunk0.base + chunkH;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, chunk1.fbo);
                    gl.viewport(0, 0, chunkW, chunkH);
                    gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                gl.useProgram(terrainProg); setupAttribs(terrainProg);
                gl.viewport(0, 0, W, H);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, chunk0.tex); gl.uniform1i(locTerrain.uChunk0, 0);
                gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, chunk1.tex); gl.uniform1i(locTerrain.uChunk1, 1);

                gl.uniform1f(locTerrain.uCameraTop, cameraTop);
                gl.uniform1f(locTerrain.uChunk0Base, chunk0.base);
                gl.uniform1f(locTerrain.uChunkSize, chunkH);
                gl.uniform2f(locTerrain.uResolution, chunkW, chunkH);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);

            window.onresize = () => {
                W = canvas.width = window.innerWidth;
                H = canvas.height = window.innerHeight;
                chunkW = Math.floor(W / SCALE);
                chunkH = Math.floor(H / SCALE);
                aspect = W / H;
                [chunk0, chunk1].forEach(chunk => {
                    gl.bindTexture(gl.TEXTURE_2D, chunk.tex);
                    gl.texImage2D(
                        gl.TEXTURE_2D,
                        0,
                        gl.RGBA32F,
                        chunkW,
                        chunkH,
                        0,
                        gl.RGBA,
                        gl.FLOAT,
                        null
                    );
                    gl.bindFramebuffer(gl.FRAMEBUFFER, chunk.fbo);
                    gl.viewport(0, 0, chunkW, chunkH);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                });
                gl.viewport(0, 0, W, H);
                chunk0.base = cameraTop;
                chunk1.base = chunk0.base + chunkH;
            };

            function setScale(newScale) {
                SCALE = newScale;
                chunkW = Math.floor(W / SCALE);
                chunkH = Math.floor(H / SCALE);
                aspect = W / H;
                [chunk0, chunk1].forEach(chunk => {
                    gl.bindTexture(gl.TEXTURE_2D, chunk.tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, chunkW, chunkH, 0, gl.RGBA, gl.FLOAT, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, chunk.fbo);
                    gl.viewport(0, 0, chunkW, chunkH);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                });
                gl.viewport(0, 0, W, H);
                gl.useProgram(dotBrushProg);
                gl.uniform1f(locDot.uAspect, aspect);
                gl.useProgram(terrainProg);
                gl.uniform2f(locTerrain.uResolution, chunkW, chunkH);
                chunk0.base = cameraTop;
                chunk1.base = chunk0.base + chunkH;
            }

            function setScrollSpeed(newSpeed) {
                scrollSpeed = newSpeed;
            }

            window.setScale = setScale
            window.setScrollSpeed = setScrollSpeed

            const themePalettes = {
                Archipelago: [
                    [0.0, 0.23, 0.36], [0.0, 0.37, 0.48], [0.0, 0.6, 0.8], [0.2, 0.6, 1.0], [1.0, 0.87, 0.67],
                    [0.42, 0.56, 0.14], [0.13, 0.55, 0.13], [0.33, 0.42, 0.19], [0.63, 0.63, 0.63], [0.75, 0.75, 0.75], [1.0, 1.0, 1.0]
                ],
                Desert: [
                    [0.25, 0.2, 0.1], [0.6, 0.5, 0.3], [0.9, 0.8, 0.5], [1.0, 0.9, 0.6], [1.0, 0.85, 0.5],
                    [0.8, 0.7, 0.4], [0.6, 0.5, 0.3], [0.5, 0.4, 0.2], [0.7, 0.65, 0.5], [0.85, 0.8, 0.7], [1.0, 1.0, 0.9]
                ],
                Ocean: [
                    [0.0, 0.2, 0.4], [0.0, 0.25, 0.45], [0.0, 0.3, 0.5], [0.0, 0.35, 0.55], [0.0, 0.4, 0.6],
                    [0.05, 0.3, 0.4], [0.05, 0.35, 0.45], [0.1, 0.4, 0.5], [0.15, 0.45, 0.55], [0.9, 0.85, 0.6], [0.95, 0.9, 0.65]
                ],
                Tundra: [
                    [0.30, 0.40, 0.60], [0.40, 0.50, 0.60], [0.48, 0.58, 0.55], [0.50, 0.63, 0.45], [0.55, 0.68, 0.40],
                    [0.60, 0.70, 0.35], [0.65, 0.65, 0.45], [0.75, 0.75, 0.60], [0.85, 0.88, 0.90], [0.93, 0.95, 0.97], [1.0, 1.0, 1.0]
                ],
                Savanna: [
                    [0.35, 0.25, 0.08], [0.4, 0.3, 0.1], [0.45, 0.35, 0.15], [0.5, 0.6, 0.25], [0.55, 0.65, 0.28],
                    [0.6, 0.7, 0.3], [0.2, 0.4, 0.1], [0.25, 0.45, 0.12], [0.3, 0.5, 0.15], [0.05, 0.15, 0.25], [0.1, 0.2, 0.3]
                ],
                Forest: [
                    [0.05, 0.20, 0.05],
                    [0.08, 0.25, 0.08],
                    [0.12, 0.30, 0.12],
                    [0.18, 0.38, 0.18],
                    [0.25, 0.45, 0.20],
                    [0.32, 0.50, 0.25],
                    [0.40, 0.55, 0.30],
                    [0.48, 0.58, 0.35],
                    [0.60, 0.60, 0.40],
                    [0.70, 0.65, 0.55],
                    [0.75, 0.70, 0.60]
                ]
            };

            function setTheme(name) {
                const pal = themePalettes[name] || themePalettes.Default;
                const flat = pal.flat();
                gl.useProgram(terrainProg);
                gl.uniform3fv(locTerrain.uPalette, flat);
            }
            setTheme('Archipelago');
            window.setTheme = setTheme;
        })();
    </script>
</body>

</html>