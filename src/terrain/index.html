<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Terrain with Incremental Height Drawing</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #111;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        (() => {
            const canvas = document.getElementById('canvas');
            const gl = canvas.getContext('webgl2');
            if (!gl) return alert('WebGL2 required');

            let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
            gl.viewport(0, 0, W, H);
            window.addEventListener('resize', () => {
                W = canvas.width = innerWidth;
                H = canvas.height = innerHeight;
                gl.viewport(0, 0, W, H);
            });

            // --- Mouse ---
            const mouse = { x: 0, y: 0, down: false };
            canvas.addEventListener('mousemove', e => {
                const r = canvas.getBoundingClientRect();
                mouse.x = (e.clientX - r.left) / W;
                mouse.y = (e.clientY - r.top) / H;
            });
            canvas.addEventListener('mousedown', () => mouse.down = true);
            window.addEventListener('mouseup', () => mouse.down = false);

            // --- Shader helpers ---
            function compile(src, type) {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
                return s;
            }
            function createProgram(vs, fs) {
                const p = gl.createProgram();
                gl.attachShader(p, compile(vs, gl.VERTEX_SHADER));
                gl.attachShader(p, compile(fs, gl.FRAGMENT_SHADER));
                gl.linkProgram(p);
                if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
                return p;
            }

            // --- Fullscreen quad ---
            const quadVerts = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
            const quadVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
            gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            const aPosLoc = 0;
            gl.enableVertexAttribArray(aPosLoc);
            gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

            const VS = `#version 300 es
in vec2 aPos;
out vec2 vUV;
void main(){ vUV=aPos*0.5+0.5; gl_Position=vec4(aPos,0,1); }`;

            // --- Dot brush FS: add height ---
            const DOT_BRUSH_FS = `#version 300 es
precision highp float;
out vec4 outColor;
uniform vec2 uDotPos;
uniform float uRadius;
uniform float uAmount;
in vec2 vUV;
void main(){
    float d = distance(vUV, uDotPos);
    if(d < uRadius){
        outColor = vec4(uAmount,0.,0.,1.);
    } else discard;
}`;

            const dotBrushProg = createProgram(VS, DOT_BRUSH_FS);
            const locDot = {
                uDotPos: gl.getUniformLocation(dotBrushProg, 'uDotPos'),
                uRadius: gl.getUniformLocation(dotBrushProg, 'uRadius'),
                uAmount: gl.getUniformLocation(dotBrushProg, 'uAmount')
            };

            // --- Terrain FS ---
            const TERRAIN_FS = `#version 300 es
precision highp float;
in vec2 vUV;
out vec4 outColor;
uniform sampler2D uChunk0;
uniform sampler2D uChunk1;
uniform float uCameraTop;
uniform float uChunk0Base;
uniform float uChunkSize;
uniform vec2 uResolution;

float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
float noise(vec2 p){ vec2 i=floor(p),f=fract(p); float a=hash(i),b=hash(i+vec2(1.,0.)),c=hash(i+vec2(0.,1.)),d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }

float proceduralHeight(vec2 worldXY){
    vec2 p = worldXY*0.02; float h=0.,amp=4.,freq=1.,maxA=0.;
    for(int i=0;i<6;i++){ h+=noise(p*freq)*amp; maxA+=amp; amp*=0.7; freq*=2.; }
    h/=maxA; float continent=noise(p*0.1)*0.75; h=h*0.6+continent*0.4;
    return pow(h*0.5+0.5,2.5)*4.-1.;
}

vec3 colorForHeight(float h){
    float n=(h+0.5)/2.;
    if(n<0.4) return mix(vec3(0.,0.23,0.36),vec3(0.,0.6,0.8),n/0.4);
    else if(n<0.6) return mix(vec3(0.2,0.6,1.),vec3(0.42,0.56,0.14),(n-0.4)/0.2);
    else return mix(vec3(0.42,0.56,0.14),vec3(1.),(n-0.6)/0.4);
}

void main(){
    vec2 worldXY = vec2(vUV.x*uResolution.x,uCameraTop+vUV.y*uResolution.y);
    float sampleDelta=0.;
    if(worldXY.y>=uChunk0Base && worldXY.y<uChunk0Base+uChunkSize){
        float ly=(worldXY.y-uChunk0Base)/uChunkSize; ly=clamp(ly,0.,1.);
        sampleDelta = texture(uChunk0,vec2(vUV.x,ly)).r;
    } else {
        float chunk1Base = uChunk0Base+uChunkSize;
        float ly=(worldXY.y-chunk1Base)/uChunkSize; ly=clamp(ly,0.,1.);
        sampleDelta = texture(uChunk1,vec2(vUV.x,ly)).r;
    }
    float finalH = proceduralHeight(worldXY)+sampleDelta;
    vec3 baseCol = colorForHeight(finalH);
    outColor = vec4(baseCol,1.);
}`;

            const terrainProg = createProgram(VS, TERRAIN_FS);

            function setupAttribs(prog) {
                const aPos = gl.getAttribLocation(prog, 'aPos');
                gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
                gl.enableVertexAttribArray(aPos);
                gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
            }

            // --- Chunk creation ---
            function createChunk() {
                const texA = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texA);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                const fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texA, 0);

                // Check completeness immediately
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                    console.error('Chunk framebuffer incomplete!');
                }

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                return { texA, fbo, base: 0 };
            }


            let chunk0 = createChunk(), chunk1 = createChunk();
            chunk0.base = 0; chunk1.base = H;

            const locTerrain = {
                uChunk0: gl.getUniformLocation(terrainProg, 'uChunk0'),
                uChunk1: gl.getUniformLocation(terrainProg, 'uChunk1'),
                uCameraTop: gl.getUniformLocation(terrainProg, 'uCameraTop'),
                uChunk0Base: gl.getUniformLocation(terrainProg, 'uChunk0Base'),
                uChunkSize: gl.getUniformLocation(terrainProg, 'uChunkSize'),
                uResolution: gl.getUniformLocation(terrainProg, 'uResolution')
            };

            // --- Draw dot as incremental height ---
            function drawDotContinuous(xNorm, yNorm) {
                const dotRadius = 0.02;
                const heightIncrement = 0.01;
                const worldY = -cameraTop + yNorm * H;

                [chunk0, chunk1].forEach(chunk => {
                    const yInChunk = (1 - yNorm) * H - (chunk.base - cameraTop);
                    const yChunkNorm = yInChunk / H;

                    if (yChunkNorm + dotRadius >= 0 && yChunkNorm - dotRadius <= 1) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, chunk.fbo);
                        gl.viewport(0, 0, W, H);

                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.ONE, gl.ONE); // additive
                        gl.useProgram(dotBrushProg);
                        setupAttribs(dotBrushProg);

                        gl.uniform2f(locDot.uDotPos, xNorm, yChunkNorm);
                        gl.uniform1f(locDot.uRadius, dotRadius);
                        gl.uniform1f(locDot.uAmount, heightIncrement);

                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        gl.disable(gl.BLEND);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    }
                });
            }

            canvas.addEventListener('mousedown', () => drawDotContinuous(mouse.x, mouse.y));
            canvas.addEventListener('mousemove', () => { if (mouse.down) drawDotContinuous(mouse.x, mouse.y); });

            // --- Camera ---
            let cameraTop = 0, scrollSpeed = 0.8;

            function frame() {
                cameraTop += scrollSpeed;
                if (cameraTop >= chunk1.base) {
                    [chunk0, chunk1] = [chunk1, chunk0];
                    chunk1.base = chunk0.base + H;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, chunk1.fbo);
                    gl.viewport(0, 0, W, H);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, chunk1.texA, 0);
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                // render terrain
                gl.useProgram(terrainProg);
                setupAttribs(terrainProg);
                gl.viewport(0, 0, W, H);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, chunk0.texA);
                gl.uniform1i(locTerrain.uChunk0, 0);

                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, chunk1.texA);
                gl.uniform1i(locTerrain.uChunk1, 1);

                gl.uniform1f(locTerrain.uCameraTop, cameraTop);
                gl.uniform1f(locTerrain.uChunk0Base, chunk0.base);
                gl.uniform1f(locTerrain.uChunkSize, H);
                gl.uniform2f(locTerrain.uResolution, W, H);

                gl.drawArrays(gl.TRIANGLES, 0, 6);

                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        })();
    </script>
</body>

</html>