<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGL Terrain Pixelated + Draw</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #222;
}
canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
}
</style>
</head>
<body>
<canvas id="screen"></canvas>
<script type="module">
import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.3/dist/esm/simplex-noise.js';
const noise2D = createNoise2D();

const canvas = document.getElementById('screen');
const gl = canvas.getContext('webgl2');
const pixelSize = 6;

// Track mouse positions
const maxClicks = 16;
let clicks = [];
canvas.addEventListener('mousedown', e => {
    clicks.push({x: e.offsetX, y: e.offsetY});
    if(clicks.length>maxClicks) clicks.shift();
});

// --- Vertex shader ---
const vertexShaderSrc = `#version 300 es
in vec2 a_position;
out vec2 v_uv;
void main(){v_uv=a_position*0.5+0.5;gl_Position=vec4(a_position,0.0,1.0);}`;

// --- Fragment shader ---
const fragmentShaderSrc = `#version 300 es
precision highp float;
in vec2 v_uv;
out vec4 outColor;

uniform float u_time;
uniform vec2 u_resolution;
uniform sampler2D u_noiseTex;
uniform float u_scroll;
uniform vec2 u_clicks[${maxClicks}];
uniform int u_clickCount;
uniform float u_pixelSize;

float sampleNoise(vec2 uv){return texture(u_noiseTex, uv).r*2.0-1.0;}

float getHeight(vec2 pos){
    float baseScale = 0.02;
    float height = 0.0;
    float amplitude = 4.0;
    float freq = 1.0;
    float maxA = 0.0;

    for(int i=0;i<6;i++){
        height += sampleNoise(pos*baseScale*freq) * amplitude;
        maxA += amplitude;
        amplitude *= 0.7;
        freq *= 2.0;
    }
    height /= maxA;
    float continent = sampleNoise(pos*baseScale*0.1)*0.75;
    height = height*0.6 + continent*0.4;
    
    // Add click influence
    for(int i=0;i<${maxClicks};i++){
        if(i>=u_clickCount) break;
        vec2 click = u_clicks[i]/u_resolution;
        float dist = length(pos - click);
        height += exp(-dist*100.0)*2.0; // falloff
    }

    return pow(height*0.5+0.5,2.5)*4.0-1.0;
}

vec3 lerp(vec3 a, vec3 b, float t){return a*(1.0-t)+b*t;}

vec3 jitterColor(vec3 color, vec2 pos){
    float n = sampleNoise(pos*0.3)*0.2;
    vec3 outCol = color + n*0.1;
    return clamp(outCol,0.0,1.0);
}

vec3 getColor(float h, vec2 pos){
    float n=(h+1.0)/2.0;
    vec3 color;
    if(n<0.4){
        float t=clamp(n/0.4+sampleNoise(pos*0.1)*0.05,0.0,1.0);
        if(t<0.33) color=lerp(vec3(0.0,0.23,0.36),vec3(0.0,0.37,0.48),t/0.33);
        else if(t<0.66) color=lerp(vec3(0.0,0.37,0.48),vec3(0.0,0.6,0.8),(t-0.33)/0.33);
        else color=lerp(vec3(0.0,0.6,0.8),vec3(0.2,0.6,1.0),(t-0.66)/0.34);
    } else if(n<0.5) color=lerp(vec3(0.2,0.6,1.0),vec3(1.0,0.87,0.67),(n-0.4)/0.1);
    else if(n<0.6){
        float t=(n-0.5)/0.1;
        if(t<0.3) color=lerp(vec3(1.0,0.87,0.67),vec3(0.42,0.56,0.14),t/0.3);
        else color=vec3(0.42,0.56,0.14);
    } else if(n<0.7) color=lerp(vec3(0.42,0.56,0.14),vec3(0.13,0.55,0.13),(n-0.6)/0.1);
    else if(n<0.8) color=lerp(vec3(0.13,0.55,0.13),vec3(0.34,0.42,0.18),(n-0.7)/0.1);
    else if(n<0.87){
        float t=(n-0.8)/0.07;
        if(t<0.4) color=lerp(vec3(0.34,0.42,0.18),vec3(0.63,0.63,0.63),t/0.4);
        else color=vec3(0.63,0.63,0.63);
    } else if(n<0.95) color=lerp(vec3(0.63,0.63,0.63),vec3(0.75,0.75,0.75),(n-0.87)/0.08);
    else color=lerp(vec3(0.75,0.75,0.75),vec3(1.0,1.0,1.0),(n-0.95)/0.05);
    return jitterColor(color,pos);
}

void main(){
    float aspect = u_resolution.x/u_resolution.y;
    vec2 uv = v_uv;
    uv.x *= aspect;

    float worldY = uv.y*u_resolution.y + u_scroll;
    float snapY = floor(worldY/u_pixelSize)*u_pixelSize;
    float snapX = floor(uv.x*u_resolution.y/u_pixelSize)*u_pixelSize;

    vec2 pos = vec2(snapX/u_resolution.y, snapY/u_resolution.y);
    float h = getHeight(pos*10.0);
    vec3 color = getColor(h,pos);
    outColor = vec4(color,1.0);
}`;

// --- Compile & link shaders ---
function compileShader(type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(shader));
    return shader;
}
const vs = compileShader(gl.VERTEX_SHADER, vertexShaderSrc);
const fs = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(program));
gl.useProgram(program);

// Fullscreen quad
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(program,'a_position');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

// Uniforms
const timeLoc = gl.getUniformLocation(program,'u_time');
const resLoc = gl.getUniformLocation(program,'u_resolution');
const scrollLoc = gl.getUniformLocation(program,'u_scroll');
const clicksLoc = gl.getUniformLocation(program,'u_clicks');
const clickCountLoc = gl.getUniformLocation(program,'u_clickCount');
const pixelSizeLoc = gl.getUniformLocation(program,'u_pixelSize');

// Resize
let width,height;
function resize(){
    width=window.innerWidth;
    height=window.innerHeight;
    canvas.width=width;
    canvas.height=height;
    gl.viewport(0,0,width,height);
    gl.uniform2f(resLoc,width,height);
}
window.addEventListener('resize',resize);
resize();

// Noise texture
const noiseSize=256;
const noiseData=new Uint8Array(noiseSize*noiseSize*4);
for(let y=0;y<noiseSize;y++){
    for(let x=0;x<noiseSize;x++){
        let n=noise2D(x/10,y/10)*0.5+0.5;
        let idx=(y*noiseSize+x)*4;
        let v=Math.floor(n*255);
        noiseData[idx]=noiseData[idx+1]=noiseData[idx+2]=v;
        noiseData[idx+3]=255;
    }
}
const noiseTex=gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D,noiseTex);
gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,noiseSize,noiseSize,0,gl.RGBA,gl.UNSIGNED_BYTE,noiseData);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D,noiseTex);
gl.uniform1i(gl.getUniformLocation(program,'u_noiseTex'),0);

// Animate
let scrollY = 0;
function animate(t){
    scrollY+=0.5;
    gl.uniform1f(scrollLoc,scrollY);
    gl.uniform1f(timeLoc,t*0.001);

    // Send click positions
    const flatClicks = new Float32Array(maxClicks*2);
    for(let i=0;i<clicks.length;i++){
        flatClicks[i*2] = clicks[i].x;
        flatClicks[i*2+1] = height - clicks[i].y;
    }
    gl.uniform2fv(clicksLoc,flatClicks);
    gl.uniform1i(clickCountLoc,clicks.length);
    gl.uniform1f(pixelSizeLoc,pixelSize);

    gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
