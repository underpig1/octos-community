<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mandelbrot</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background-color: black;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            border: 1px solid white;
            pointer-events: none;
        }

        button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            /* display: none; */
            z-index: 10;
        }

        #copyCanvas {
            pointer-events: none;
            display: none;
        }

        #info {
            left: 10px;
            right: auto;
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <canvas id="copyCanvas"></canvas>
    <div id="overlay"></div>
    <button id="resetZoom">Reset Zoom</button>
    <script src="./mandelbrot.js"></script>
    <button id="info" onclick="window.open('https://github.com/underpig1/octos-community/tree/master/src/fractal', '_blank');">?</button>
    <script>
        (async () => {
            const numWorkers = Math.max(2, navigator.hardwareConcurrency || 4);
            const tileHeight = 32;
            const maxIter = 500;

            const canvas = document.getElementById('canvas');
            const copyCanvas = document.getElementById('copyCanvas', { alpha: true });
            const ctx = canvas.getContext('2d');
            let width = canvas.width = window.innerWidth;
            let height = canvas.height = window.innerHeight;

            let center = { x: -0.5, y: 0 };
            let scale = 3.0;
            const initialScale = 3.0;
            const initialCenter = { x: -0.5, y: 0 };

            const resetBtn = document.getElementById("resetZoom");

            function updateResetButton() {
                resetBtn.style.display = 'block';
                if (scale !== initialScale || center.x !== initialCenter.x || center.y !== initialCenter.y) {
                    // resetBtn.style.display = 'block';
                    resetBtn.innerText = 'Reset Zoom'
                    resetBtn.style.opacity = 1
                } else {
                    // resetBtn.style.display = 'none';
                    resetBtn.innerText = 'Click and drag to zoom'
                    resetBtn.style.opacity = 0.5
                }
            }

            const mandelbrotJsUrl = new URL('mandelbrot.js', window.location.href).href;

            // Worker logic as string
            const workerCode = `
        let mandelbrotModulePromise = null;
    
        self.onmessage = async (e) => {
            const { width, height, centerX, centerY, scale, maxIter, yStart, yEnd, mandelbrotJsUrl } = e.data;
    
            if (!mandelbrotModulePromise) {
                importScripts(mandelbrotJsUrl);
                mandelbrotModulePromise = MandelbrotModule({
                    locateFile: (path) => new URL(path, mandelbrotJsUrl).href
                }).then(mod => {
                    mod._exposeHeap();
                    return mod;
                });
            }
    
            const mandelbrot = await mandelbrotModulePromise;
            const ptr = mandelbrot._allocBuffer(width, height);
            const pixels = new Uint8ClampedArray(mandelbrot.HEAPU8.buffer, ptr, width * height * 4);
            mandelbrot._computeMandelbrotTile(width, height, centerX, centerY, scale, maxIter, yStart, yEnd);
    
            const tilePixels = pixels.slice(yStart * width * 4, yEnd * width * 4);
            self.postMessage({ yStart, yEnd, pixels: tilePixels }, [tilePixels.buffer]);
        };
        `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerURL = URL.createObjectURL(blob);

            const workers = Array.from({ length: numWorkers }, () => new Worker(workerURL));

            function render() {
                updateResetButton();
                let pending = 0;

                return new Promise((resolve) => {
                    let y = 0;
                    const nextTile = (worker) => {
                        if (y >= height) return;

                        const yStart = y;
                        const yEnd = Math.min(y + tileHeight, height);
                        y = yEnd;
                        pending++;

                        worker.onmessage = (msg) => {
                            const { yStart, yEnd, pixels } = msg.data;
                            const imageData = new ImageData(new Uint8ClampedArray(pixels), width, yEnd - yStart);
                            ctx.putImageData(imageData, 0, yStart);
                            pending--;
                            if (pending === 0 && y >= height) {
                                resolve();
                            } else {
                                nextTile(worker);
                            }
                        };

                        worker.postMessage({
                            width, height,
                            centerX: center.x,
                            centerY: center.y,
                            scale,
                            maxIter,
                            yStart, yEnd,
                            mandelbrotJsUrl
                        });
                    };

                    workers.forEach((w) => nextTile(w));
                });
            }

            let dragging = false, dragStart = { x: 0, y: 0 }, dragEnd = { x: 0, y: 0 };
            const overlay = document.getElementById('overlay');

            canvas.addEventListener('mousedown', e => {
                overlay.style.transform = 'none'
                dragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
                // overlay.style.display = 'block';
                overlay.style.width = '0px';
                overlay.style.height = '0px';
                overlay.style.left = dragStart.x + 'px';
                overlay.style.top = dragStart.y + 'px';
                overlay.style.opacity = 0;
            });

            canvas.addEventListener('mousemove', e => {
                if (!dragging) return;
                dragEnd = { x: e.clientX, y: e.clientY };
                const x = Math.min(dragStart.x, dragEnd.x);
                const y = Math.min(dragStart.y, dragEnd.y);
                overlay.style.left = x + 'px';
                overlay.style.top = y + 'px';
                overlay.style.width = Math.abs(dragEnd.x - dragStart.x) + 'px';
                overlay.style.height = Math.abs(dragEnd.y - dragStart.y) + 'px';
                overlay.style.opacity = 1;
            });

            canvas.addEventListener('mouseup', e => {
                if (!dragging) return;
                dragging = false;
                // overlay.style.display = 'none';

                const minX = Math.min(dragStart.x, dragEnd.x);
                const maxX = Math.max(dragStart.x, dragEnd.x);
                const minY = Math.min(dragStart.y, dragEnd.y);
                const maxY = Math.max(dragStart.y, dragEnd.y);

                const left = (minX - width / 2) * scale / height + center.x;
                const right = (maxX - width / 2) * scale / height + center.x;
                const top = (height / 2 - minY) * scale / height + center.y;
                const bottom = (height / 2 - maxY) * scale / height + center.y;
                if (minX == 0 && minY == 0) {
                    // zoomTo(right, bottom, 0.5*scale * height / width)
                    return;
                }

                const boxWidth = Math.abs(right - left);

                const x = (left + right) / 2
                const y = (top + bottom) / 2
                const s = boxWidth * height / width
                zoomTo(x, y, s)
            });

            function worldToCanvas(xWorld, yWorld, worldScale, element = canvas) {
                const w = element.width || parseInt(element.style.width);
                const h = element.height || parseInt(element.style.height);
                const s = scale / worldScale;
                const dx = (center.x - xWorld) * h / worldScale;
                const dy = (yWorld - center.y) * h / worldScale;
                return { dx, dy, s };
            }

            const copyCtx = copyCanvas.getContext('2d');
            copyCanvas.width = canvas.width;
            copyCanvas.height = canvas.height;

            function zoomTo(x, y, newScale) {
                console.log('zooming to')
                canvas.style.display = "none"
                copyCanvas.style.display = "block";
                copyCanvas.style.opacity = '1';
                copyCanvas.style.transform = "none";
                copyCanvas.style.transition = 'none';
                copyCtx.clearRect(0, 0, copyCanvas.width, copyCanvas.height);
                copyCtx.drawImage(canvas, 0, 0);
                const { dx, dy, s } = worldToCanvas(x, y, newScale)
                overlay.width = parseInt(overlay.style.width)
                overlay.height = parseInt(overlay.style.height)
                const o = worldToCanvas(x, y, newScale, overlay)

                const transformDuration = 200;
                const opacityDuration = 200;

                const ax = (canvas.width - canvas.width / s) / 2 - dx / s;
                const ay = (canvas.height - canvas.height / s) / 2 - dy / s;
                overlay.style.transition = `transform ${transformDuration/1000}s ease-in-out, opacity ${transformDuration/1000}s ease-in-out`;
                overlay.style.transformOrigin = 'center center'
                requestAnimationFrame(() => {
                    copyCanvas.style.transition = `transform ${transformDuration/1000}s ease-in-out, opacity ${opacityDuration/1000}s ease-in-out`;
                    copyCanvas.style.transform = `translate(${dx}px, ${dy}px) scale(${s})`;
                    overlay.style.transform = `translate(${dx* parseInt(overlay.style.width) /canvas.width }px, ${dy * parseInt(overlay.style.height) / canvas.height}px) scale(${s})`;
                    overlay.style.opacity = 0
                })

                center.x = x
                center.y = y
                scale = newScale
                
                const rectCoords = {
                    w: canvas.width / s,
                    h: canvas.height / s,
                    x: (canvas.width - canvas.width / s) / 2 - dx / s,
                    y: (canvas.height - canvas.height / s) / 2 - dy / s
                }

                // copyCtx.strokeStyle = 'white'
                // copyCtx.strokeRect(rectCoords.x, rectCoords.y, rectCoords.w, rectCoords.h);

                Promise.all([
                    render().then(() => {
                        copyCtx.drawImage(canvas, rectCoords.x, rectCoords.y, rectCoords.w, rectCoords.h)
                        // copyCanvas.style.opacity = '0';

                        // copyCtx.strokeStyle = 'white'
                        // copyCtx.strokeRect(rectCoords.x, rectCoords.y, rectCoords.w, rectCoords.h);

                        // zoomingCanvas.style.opacity = '1'
                        // zoomingCtx.drawImage(canvas, 0, 0);
                    }),
                    new Promise(resolve => setTimeout(resolve, transformDuration)).then(() => {
                        overlay.style.transition = 'none'
                        overlay.style.opacity = 0;
                    })
                ]).then(() => {
                    copyCanvas.style.opacity = '0';
                    setTimeout(() => copyCanvas.style.display = 'none', transformDuration);
                    canvas.style.display = 'block'
                });
                updateResetButton();
            }

            resetBtn.addEventListener('click', () => {
                // center = { ...initialCenter };
                // scale = initialScale;
                console.log('dezooming');
                zoomTo(initialCenter.x, initialCenter.y, initialScale);
                // render();
            });

            window.addEventListener('resize', () => {
                width = canvas.width = copyCanvas.width = window.innerWidth;
                height = canvas.height = copyCanvas.height = window.innerHeight;
                render();
            });

            render();
        })();
    </script>
</body>

</html>