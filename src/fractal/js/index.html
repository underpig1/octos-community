<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mandelbrot Infinite Zoom Optimized</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            border: 1px solid white;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="overlay"></div>
    <script>
        const canvas = document.getElementById("canvas");
        const overlay = document.getElementById("overlay");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let center = { x: -0.5, y: 0 };
        let scale = 3.0;
        let maxIter = 500;

        // Drag zoom
        let dragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragEnd = { x: 0, y: 0 };

        // Check if point is inside main cardioid or period-2 bulb
        function inCardioidOrBulb(x, y) {
            const p = Math.sqrt((x - 0.25) ** 2 + y * y);
            if (x < p - 2 * p * p + 0.25) return true; // main cardioid
            if ((x + 1) ** 2 + y * y < 0.0625) return true; // period-2 bulb
            return false;
        }

        // HSL to RGB helper
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        }

        // Render Mandelbrot
        function render() {
            const img = ctx.createImageData(canvas.width, canvas.height);
            const data = img.data;

            for (let py = 0; py < canvas.height; py++) {
                const y0 = (canvas.height / 2 - py) * scale / canvas.height + center.y;
                for (let px = 0; px < canvas.width; px++) {
                    const x0 = (px - canvas.width / 2) * scale / canvas.height + center.x;

                    let idx = 4 * (py * canvas.width + px);

                    if (inCardioidOrBulb(x0, y0)) {
                        data[idx] = data[idx + 1] = data[idx + 2] = 0;
                        data[idx + 3] = 255;
                        continue;
                    }

                    let x = 0, y = 0, iter = 0;
                    while (x * x + y * y <= 4 && iter < maxIter) {
                        const xt = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xt;
                        iter++;
                    }

                    // Smooth iteration
                    let mu = iter;
                    if (iter < maxIter) {
                        const log_zn = Math.log(x * x + y * y) / 2;
                        const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                        mu = iter + 1 - nu;
                    }

                    const hue = Math.pow(mu / maxIter, 0.6);  // 0..1
                    const rgb = hslToRgb(hue, 0.8, iter < maxIter ? 0.5 : 0);
                    data[idx] = rgb[0];
                    data[idx + 1] = rgb[1];
                    data[idx + 2] = rgb[2];
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(img, 0, 0);
        }

        // Initial render
        render();

        // Mouse events
        canvas.addEventListener("mousedown", e => {
            dragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            overlay.style.left = dragStart.x + "px";
            overlay.style.top = dragStart.y + "px";
            overlay.style.width = "0px";
            overlay.style.height = "0px";
            overlay.style.display = "block";
        });

        canvas.addEventListener("mousemove", e => {
            if (dragging) {
                dragEnd = { x: e.clientX, y: e.clientY };
                const x = Math.min(dragStart.x, dragEnd.x);
                const y = Math.min(dragStart.y, dragEnd.y);
                const w = Math.abs(dragEnd.x - dragStart.x);
                const h = Math.abs(dragEnd.y - dragStart.y);
                overlay.style.left = x + "px";
                overlay.style.top = y + "px";
                overlay.style.width = w + "px";
                overlay.style.height = h + "px";
            }
        });

        canvas.addEventListener("mouseup", e => {
            if (dragging) {
                dragging = false;
                overlay.style.display = "none";

                const minX = Math.min(dragStart.x, dragEnd.x);
                const maxX = Math.max(dragStart.x, dragEnd.x);
                const minY = Math.min(dragStart.y, dragEnd.y);
                const maxY = Math.max(dragStart.y, dragEnd.y);

                const left = (minX - canvas.width / 2) * scale / canvas.height + center.x;
                const right = (maxX - canvas.width / 2) * scale / canvas.height + center.x;
                const top = (canvas.height / 2 - minY) * scale / canvas.height + center.y;
                const bottom = (canvas.height / 2 - maxY) * scale / canvas.height + center.y;

                const boxWidth = Math.abs(right - left);
                const boxHeight = Math.abs(top - bottom);
                const canvasAR = canvas.width / canvas.height;

                if (boxWidth / boxHeight > canvasAR) {
                    scale = boxWidth * canvas.height / canvas.width;
                } else {
                    scale = boxHeight;
                }

                center.x = (left + right) / 2;
                center.y = (top + bottom) / 2;

                maxIter = Math.min(10000, Math.floor(500 + 200 * Math.log10(3.0 / scale)));

                render();
            }
        });
    </script>
</body>

</html>