<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mandelbrot WASM Progressive</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            border: 1px solid white;
            pointer-events: none;
        }

        #resetZoom {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            display: none;
            z-index: 10;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div id="overlay"></div>
    <button id="resetZoom">Reset Zoom</button>
    <script src="mandelbrot.js"></script>
    <script>
        (async () => {
            const mandelbrot = await MandelbrotModule();
            mandelbrot._exposeHeap();

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let width = canvas.width = window.innerWidth;
            let height = canvas.height = window.innerHeight;

            const maxIter = 500;
            const tileHeight = 32;

            let ptr = mandelbrot._allocBuffer(width, height);
            let pixels = new Uint8ClampedArray(mandelbrot.HEAPU8.buffer, ptr, width * height * 4);

            let center = { x: -0.5, y: 0 };
            let scale = 3.0;
            const initialScale = 3.0;
            const initialCenter = { x: -0.5, y: 0 };

            const resetBtn = document.getElementById("resetZoom");

            function updateResetButton() {
                if (scale !== initialScale || center.x !== initialCenter.x || center.y !== initialCenter.y) {
                    resetBtn.style.display = 'block';
                } else {
                    resetBtn.style.display = 'none';
                }
            }

            function render() {
                let y = 0;
                function renderNextTile() {
                    const yEnd = Math.min(y + tileHeight, height);
                    mandelbrot._computeMandelbrotTile(width, height, center.x, center.y, scale, maxIter, y, yEnd);
                    ctx.putImageData(new ImageData(pixels, width, height), 0, 0);
                    y = yEnd;
                    if (y < height) requestAnimationFrame(renderNextTile);
                }
                renderNextTile();
                updateResetButton();
            }

            // Click-to-zoom
            canvas.addEventListener('click', e => {
                // Convert click position to Mandelbrot coordinates
                center.x = (e.clientX - width / 2) * scale / height + center.x;
                center.y = (height / 2 - e.clientY) * scale / height + center.y;

                scale = 0.9* scale
                render();
            });

            // Drag-to-zoom box
            let dragging = false, dragStart = { x: 0, y: 0 }, dragEnd = { x: 0, y: 0 };
            const overlay = document.getElementById('overlay');

            canvas.addEventListener('mousedown', e => {
                dragging = true;
                dragStart = { x: e.clientX, y: e.clientY };
                overlay.style.left = e.clientX + 'px';
                overlay.style.top = e.clientY + 'px';
                overlay.style.width = '0px';
                overlay.style.height = '0px';
                overlay.style.display = 'block';
            });

            canvas.addEventListener('mousemove', e => {
                if (!dragging) return;
                dragEnd = { x: e.clientX, y: e.clientY };
                const x = Math.min(dragStart.x, dragEnd.x);
                const y = Math.min(dragStart.y, dragEnd.y);
                overlay.style.left = x + 'px';
                overlay.style.top = y + 'px';
                overlay.style.width = Math.abs(dragEnd.x - dragStart.x) + 'px';
                overlay.style.height = Math.abs(dragEnd.y - dragStart.y) + 'px';
            });

            canvas.addEventListener('mouseup', e => {
                if (!dragging) return;
                dragging = false;
                overlay.style.display = 'none';

                const minX = Math.min(dragStart.x, dragEnd.x);
                const maxX = Math.max(dragStart.x, dragEnd.x);
                const minY = Math.min(dragStart.y, dragEnd.y);
                const maxY = Math.max(dragStart.y, dragEnd.y);

                const left = (minX - width / 2) * scale / height + center.x;
                const right = (maxX - width / 2) * scale / height + center.x;
                const top = (height / 2 - minY) * scale / height + center.y;
                const bottom = (height / 2 - maxY) * scale / height + center.y;

                const boxWidth = Math.abs(right - left);
                const boxHeight = Math.abs(top - bottom);
                const canvasAR = width / height;
                scale = boxWidth * height / width;
                // else scale = boxHeight;

                center.x = (left + right) / 2;
                center.y = (top + bottom) / 2;

                render();
            });

            // Reset zoom button
            resetBtn.addEventListener('click', () => {
                center = { ...initialCenter };
                scale = initialScale;
                render();
            });

            window.addEventListener('resize', () => {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                ptr = mandelbrot._allocBuffer(width, height);
                pixels = new Uint8ClampedArray(mandelbrot.HEAPU8.buffer, ptr, width * height * 4);
                render();
            });

            render();
        })();
    </script>
</body>

</html>